import { Utils } from 'tio-alloy';

const { dateFormatStrings } = Utils;

const getParams = (filter, index) => {
    return [
        `filter.${index}.filter=${filter.name}`,
        `filter.${index}.quality=${filter.typeCheck}`,
        `filter.${index}.value=${filter.values}`
    ].join('&');
};

const filtersToParams = (filters) => {
    return filters.map(getParams).join('&');
};

const createFilter = (name, op, values) => {
    return {
        name,
        typeCheck: op,
        values
    };
};

const createDateRangeFilterWithType = (type, endDate, period) => {
    const { DATE_FORMAT_YEAR_MONTH_DAY } = dateFormatStrings;
    const filters = [];
    filters.push(createFilter(type, 'date-lt', endDate.format(DATE_FORMAT_YEAR_MONTH_DAY)));
    if (period) {
        filters.push(createFilter(type, 'date-gt',
            endDate.subtract(period, 'days').format(DATE_FORMAT_YEAR_MONTH_DAY)));
    }

    return filters;
};

const searchToParams = (query, defaultField) => {
    // TODO allow array of default fields
    const filter = createFilter(defaultField, 'match', query.search);

    return query.search
        ? getParams(filter, query.filters.length)
        : [];
};

const getFilterParams = (query, defaultField) => {
    if (!query || !query.filters) {
        return '';
    }

    const filterParams = [
        filtersToParams(query.filters),
        defaultField ? searchToParams(query, defaultField) : '',
        `filter.search_type=${query.search_type}`
    ].join('&');

    return `&${filterParams}`.replace(/(&){2,}/g, '&');
};

// TEMPORARY
const formatFiltersApplied = (filtersApplied) => {
    // this will go away in the future as AdvancedSearch internals are refactored
    // https://jira.corp.tenablesecurity.com/browse/PDX-1175
    return !filtersApplied.filters
        ? []
        : filtersApplied.filters.map((filter, index) => {
            return {
                index,
                name: filter.name,
                options: Array.isArray(filter.values) ? filter.values : [filter.values],
                operator: filter.typeCheck
                // group: 1 --  for non legacy and/or condition
            };
        });
};

const appendFilter = (filters, filter) => {
    // Append the filters
    if (filters !== '') {
        // TEMP - this sort of filter insertion will not be needed when we have a proper end point we can simply pass
        // the existing filters to
        // https://jira.corp.tenablesecurity.com/browse/CI-21589
        const startFilterType = filters.indexOf('&filter.search_type');
        // match the number of filter names to determine the filter index
        const filtersIndex = filters.match(/filter\.\d+\.filter=/g);
        const filtersStart = filters.substring(0, startFilterType);
        const filtersEnd = filters.substring(startFilterType);
        // force and search type
        const filtersEndAnd = filtersEnd.replace('search_type=or', 'search_type=and');

        return `${filtersStart}&${getParams(filter, filtersIndex ? filtersIndex.length : 0)}${filtersEndAnd}`;
    }

    return `${filters}&${getParams(filter, 0)}`;
};

const appendTimeRangeFilter = (filters, timeRangeFilters) => {
    let modifiedFilter = filters;

    if (modifiedFilter.indexOf('&filter.search_type') < 0) {
        modifiedFilter = modifiedFilter.concat('&filter.search_type=and');
    }

    for (let i = 0; i < timeRangeFilters.length; i++) {
        modifiedFilter = appendFilter(modifiedFilter, timeRangeFilters[i]);
    }

    return modifiedFilter;
};

const getTimeRangeFilterParams = (filters, { filterName, endDate, duration }) => {
    const timeRangeFilters = createDateRangeFilterWithType(filterName, endDate, duration);

    return appendTimeRangeFilter(filters, timeRangeFilters);
};

export {
    appendFilter,
    createFilter,
    getParams,
    getTimeRangeFilterParams,
    filtersToParams,
    formatFiltersApplied,
    searchToParams,
    getFilterParams
};
